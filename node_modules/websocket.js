var net = require('http');
var config = require('simple').config;
var buff = require('buffer').Buffer;
var url = require('url');
 var sockets = require('sockets');
var websocket = function(req,socket,head)
{
    console.log('createin sock');
    //socket._readableState.highWaterMark =8000000;
          
	this.req = req;
	this.socket = socket;
	this.head = head;
	var obj = this;
	this.socket.on('data', function(data){obj.onData(data);});
	this.socket.on('close', this.onclose.bind(this));
    this.socket.on('error', function(err){console.log(err.code);});
    this.socket.on('end', function(){console.log('end');});
    this.cont = false;
    this.messegeEnd = false;
  //  this.socket.on('connection', function(){obj.onconnect()});
	/*/this.req.on('upgrade', function(res, socket, upgradeHead) {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
	this.bigLenght = 0;
	
  });*/
 
	this.continiousData = [];
    this.iscont ='text';
	this.appid = "";
	this.user='';
	this.params=[];
    this.rawdata=[];
    
   
    console.log('creating soc');
    
}



websocket.prototype.upgrade = function(receive, send)
{
	
	     
	      var trmd = this.req.headers['sec-websocket-key'].trim();
		  var crypto =require('crypto');
			var crypt = crypto.createHash('sha1').update(trmd+'258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64');
			
			var respns = 'HTTP/1.1 101 Switching Protocols\r\n'+
                          'Upgrade: websocket\r\n'+
                           'Connection: Upgrade\r\n'+
                            'Sec-WebSocket-Accept: '+crypt+ '\r\n'+
							'\r\n';
	  
	   this.socket.write(respns,function(err)
	   {
		   if(err)
		     console.log(err);});
	   
	   //this.socket.pipe(this.socket);
	   try{
		var urlparts = url.parse(this.req.url,true);
		
		var pathnm = urlparts.pathname.slice(1);
		
	
		var arrurl = pathnm.split('/');
	    var  quer = urlparts.query;
		
		
		 if(quer.user !== undefined)
          {
              this.user = quer.user;
          }
		 var ctrl = arrurl[0];
		 arrurl.shift();
		
		 this.receiver = arrurl[0]; 
		 arrurl.shift();
		 
		 arrurl = arrurl.map(function(x){return websocket.replaceSpecial(x);});
		 if(arrurl.length > 0)
		    this.params = arrurl;
		// this.reciever = arrurl[1];
         if(ctrl !== '')
         {
         try
         {
	     var reslv = require.resolve('../application/controller/'+ctrl);
         var simplectr = require('simple').simplecontroler;
         
		 var ctr = require('../application/controller/'+ctrl);
         ctr.__proto__ = new simplectr();
         var ctro = Object.create(ctr);
		 this.controler = ctro;
         this.controler.create(this.res, this.req);
		 this.controler.req.requestdata = quer;
          
		 //ctr.socket = this.socket;
		 //ctr.setSocket(this.socket);
         
         }
         catch(err)
         {
             
         }
         }	
		
		//var ext = path.extname(reslv);
		//var fn = path.basename(reslv.slice(0,-ext.length));
		//ctr = require('../application/controller/'+fn);
	   }
	   catch(err)
	   {
		   console.log(err);
	   }
	   
}

websocket.replaceSpecial = function(txt)
{
	
	//console.log(txt);
	return txt.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

}

websocket.prototype.onData=function(data)
{
   //  console.log(this.socket.bufferSize,'bfsize'); 
	
	this.readMessage(data);
}

websocket.prototype.readMessage = function(data)
{
   
  
	var next = 2;
	var key =[];
	//this.iscont ='text';
	var senddata='';
	var length=0;
	var FIN = (data[0] & 0x80);
    var RSV1 = (data[0] & 0x40);
     var RSV2 = (data[0] & 0x20);
     var RSV3 = (data[0] & 0x10);
	 var mask = (data[1] & 0x80);
	 var Opcode = data[0]& 0x0F;
    // console.log(data.byteLength, 'll', Opcode,FIN);
	// console.log(Opcode, FIN);
		//console.log(Opcode,FIN, this.continiousData.length,'control');
   // console.log(data[1],mask);
   var l = (data[1] & 0x7F);;
    if(mask !==0)
    var ln=0;
    if(mask===0)
    {
        ln = data[1];
        
    }
    else{
        ln = data[1] - 128;
    }
    
	if(l <= 125 )
    {
      if(mask !==0)
	    length = data[1] - 128;
      else
        length =data[1];
      length = Math.abs(length);
     // console.log(length);
      console.log(length,'small',Opcode,FIN);
    }
	else if(l === 126)
	{
		next+= 2;
        length = data.readUInt16BE(2);
		//length = (data[2] & 0xFF) << 8 | (data[3] & 0xFF);
        length = Math.abs(length);
        
        console.log(length,'med',Opcode,FIN);
        //console.log(length);
      //  console.log(length,mask);
        //console.log(length,'medium');
	}
	else if(l ===127)
	{  
		
		// var arr1 = ((data[2] & 0xFF) << 24  | (data[3] & 0xFF) <<16 | (data[4] & 0xFF) << 8 | data[5] & 0xFF) |  ((data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		//var arr1 = ((data[2] & 0xFF) << 56  | (data[3] & 0xFF) <<48 | (data[4] & 0xFF) << 40 | (data[5] & 0xFF)<<32 |  (data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		 hb = data.readUInt32BE(2);
         if(hb !== 0)
           return;
         length = data.readUInt32BE(6);
		//console.log(l,'newl');
	     // var arr2=   ((data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		  
    	  length = Math.abs(length); //+ arr2;
         // console.log(arr1);
         console.log(length,'big',Opcode,FIN);
         next+=8;
         
	}
    
    if(Opcode === 1   &&  this.continiousData.length ===0)
	          this.iscont = 'text';
    if(Opcode === 2  && this.continiousData.length ===0)
	          this.iscont = 'bin';
    if(this.continiousData.length === 0 && FIN === 0 && Opcode <=2 && Opcode >0)
    {
        
       this.cont = true;
    }
    if(this.continiousData.length === 0 && FIN !== 0 && Opcode <=2 && Opcode >0)
    {
        
       this.cont = false;
    }
    
   var decoded
   

	if(mask)
	{
	  key = data.slice(next, next + 4)
     // console.log('key',key)
	  next += 4;
	}
   
	if(Opcode ===1 || Opcode ===2||Opcode === 0)
	{
    
	var loops =1;
    if(length > 65535)
	  loops = Math.ceil(length/65535);
	 var message = data.slice(next,next+length);
    //console.log(message.length);
	// console.log(length);
	try{
      
	  decoded = new buff(message.length);
     }
     catch(er)
     {
        console.log(err);
        // return;
     }  
    
	for (var i = 0; i <  message.length; i++) {
		
       decoded[i] =  (message[i] ^ key[i % 4]);
      }     
			if(((Opcode === 1 || Opcode ===2) && this.cont === false)  || (this.cont === true && Opcode===0) || ((Opcode === 1 || Opcode ===2) && this.continiousData.length === 0) )
			{  if(this.cont ===true  && this.continiousData.length >0 && (Opcode !== 0))
                  ;// return;
             //  if(this.cont ===true  && this.continiousData.length >0 && (this.iscont === 'text' && Opcode !== 1))
                 //return;
               // console.log(this.cont,'mem',Opcode,FIN,this.iscont,length);
                //console.log(decoded.length);
				if(decoded.length !==0)
                {
			     this.continiousData.push(decoded); 
                 this.rawdata.push(message);
                }
				
			}
            
            
			    var b;
                var rd;
			   if(((this.iscont ==='text' || this.iscont === 'bin') && (this.cont === false && FIN!==0) ) ||((this.iscont ==='text' || this.iscont === 'bin') && (this.cont === true && Opcode ===0 && FIN!==0 )) )
			     {
                 
			      b =buff.concat(this.continiousData);
                 // console.log(b.length, 'length of data');
				  this.continiousData =[];
                  rd=buff.concat(this.rawdata);
                  this.rawdata=[];
                  this.cont=false;
                  this.messegeEnd = true;
				 }
                 
                 
             
			// console.log(this.messegeEnd,FIN,this.iscont);
			  if(FIN!==0 && this.iscont==='text' && this.messegeEnd ===true)
			  {
                  
                  this.messegeEnd = false;
                  this.iscont = '';
                //  console.log('abcd',Opcode);
				  if(b !== undefined)
                  {
                   // console.log(b,'thestring',b.length);
                    var obj;
                   try{
                       if(b !=='')
				        obj= JSON.parse(b.toString());
                       //console.log(obj);
                     
                   }
                   catch(ex)
                   {
                       
                       console.log(ex,'an error', b.toString());
                     //  return;
                   }
                   var tosock;
                   if(obj !== undefined)
                    tosock= obj.touser;
                    
				  
                   if(obj !== undefined)
                   {
				   if(obj.message_type == "HANDSHAKE")
				   {
                       var msk = this;
					   this.controler.setstatus(obj.user,'online');
					  // this.user = obj.user !== undefined ? obj.user:'guest'+sockets.length;
					   this.appID = obj.appID;
					   if(obj.user !==undefined)
					    { if(sockets[obj.user] !== undefined)
                            {
                               //console.log('hsk');
                               //sockets[obj.user]={};
                               // delete sockets[obj.user];  
                            }
                              this.user = obj.user;
                              this.socket.user = obj.user;
                             
                              if( sockets[obj.user] == undefined)
                                 sockets[obj.user] = [];
                              this.socket.skid = sockets[obj.user].length;
					     	  sockets[obj.user].push(this);
						     
						     
                               this.pingpong();
                              // console.log(Object.keys(sockets));
                            
                             initiateUserconnections(this, this.controler,obj);
						}
					  else
					   {
                        
                        this.user = 'guest'+Object.keys(sockets).length;
					    sockets['guest'+ Object.keys(sockets).length] = this;
						 
						 this.socket.user = this.user;
                         
                         
					   }
                       
						
					 senddata={user:this.user,message:'connected',appID:obj.appID, message_type:obj.message_type}
				 
				   }
				  else if(obj.message_type == "DISCONECT")
				   {
					   this.socket.end();
				   }
                   else if(obj.message_type == "pong")
				   {   console.log('ponger');
					   this.socket.pingssent = 0;
				   }
                   else
                   {
                   
				// vat temp = this.params;
                  // console.log(obj.message[0]);
				  this.params.unshift();
                 
				  senddata = {user:this.user,message:obj.message,appID:obj.appID, message_type:obj.message_type}
                 
                  if(this.controler !== undefined)
                  {
                   
                  this.controler.req.postdata = {to:obj.touser, from:this.user, message:obj.message, tousername:obj.tousername, fromusername:obj.fromusername}
                  if(this.receiver !== undefined)
			        this.controler[this.receiver].apply(this.controler,this.params);
                  }
				  this.params.splice(0,1);
                   }
                   }
                   
                   if(tosock !== undefined)
                     {
                        
                        tosoc = sockets[tosock];
                        
                        
                         if(tosoc !==undefined)
                         {
                         
                          this.controler.req.postdata.status='online';
                             
                           if(Object.keys(senddata).length >0)
                           {
                               
                              
                             if(obj.message_type == 'REQUEST')
                             {
                              console.log(this.controler.req.postdata , 'hollycow');
                              var msk = this;
                               
                              this.controler.findreqtofrom(obj.touser, this.user, function(req)
                              {  
                               
                               if(Object.keys(req).length == 0)
                               {
                                
                               msk.controler.finduserbyuid(msk.user, function(doc)
                               {
                                   
                                   var friended = false;
                                 for(friend in doc.friends)
                                 {   console.log(doc.friends[friend]);
                                     if(doc.friends[friend] === obj.touser)
                                      friended = true;
                                 }
                                 if(!friended)
                                 {
                                 senddata.username = doc.username;
                                  for(soc in tosoc)
                                      tosoc[soc].sendData(JSON.stringify(senddata));
                                  msk.controler.req.postdata.processed = false;
                                  msk.controler.addrequest();
                                 }
                                 else
                                 {
                                    senddata.message = "you are already connected with "+ doc.username;
                                    senddata.message_type = "NOTIF";
                                    msk.sendData(JSON.stringify(senddata));
                                 }
                                // console.log(senddata);
                              });
                               }
                               else
                               {
                                    senddata.message = "There is a pending request to this user";
                                    senddata.message_type = "NOTIF";
                                    var mysk = sockets[msk.user];
                                    for(var ms =0; ms < mysk.length; mysk++)
                                      mysk[ms].sendData(JSON.stringify(senddata));
                               }
                              });
                              
                              
                            }
                            else
                            {
                             
                              if(obj.message_type === 'PCP')
                              {
                               
                                senddata.touser = obj.touser;
                               
                              
                                
                                  
                              }
                            
                              for(soc in tosoc)
                                 tosoc[soc].sendData(JSON.stringify(senddata));
                             if(obj.message_type ==='TEXTDATA')
                               this.controler.addmessage();
                            }
                              
                          }
                         }
                         else
                         {
                         
                         if(obj.message_type ==='TEXTDATA')
                          {
                           this.controler.req.postdata.status='offline';
                           console.log('saving message');
                           this.controler.addmessage();
                          }
                         if(obj.message_type ==='REQUEST')
                         { 
                           
                           var msk = this;
                           console.log(this.controler.req.postdata,'pdata');
                           this.controler.findreqtofrom(obj.touser, this.user, function(req)
                            {
                             
                             if(Object.keys(req).length == 0)
                              {
                                    
                                
                               msk.controler.finduserbyuid(msk.user, function(doc)
                               {
                                
                                 var friended = false;
                                 for(friend in doc.friends)
                                 {   
                                     if(doc.friends[friend] === obj.touser)
                                      friended = true;
                                 }
                                 if(! friended)
                                 {
                                     
                                     msk.controler.req.postdata.processed = false;
                                     msk.controler.addrequest();
                                 }
                                 else
                                 {
                                    senddata.message = "you are already connected with "+ doc.username;
                                    senddata.message_type = "NOTIF";
                                    msk.sendData(JSON.stringify(senddata));
                                 }
                               });
                              }
                              else
                              {
                                    senddata.message = "There is a pending request to this user";
                                    senddata.message_type = "NOTIF";
                                    msk.sendData(JSON.stringify(senddata));
                              }
                            });
                         }
                        }
                        
                       if(obj.message_type === "ARR")
                        {
                          this.controler.req.postdata = {user:obj.user, processed:true, requester: obj.touser, action:obj.action}
                          this.controler.setrequestaction();
                          if(tosoc)
                          {
                             this.controler.finduserbyuid(this.user, function(doc)
                             {
                              for(soc in tosoc)
                              {  senddata.message ="Your invite has been "+obj.action+" by "+ doc.username;
                                 tosoc[soc].sendData(JSON.stringify(senddata));
                                //todo: when user accepts request alert user accepyingwhen processing done in order to remove the ui component;
                              }
                             });
                          }
                         }
                         if(obj.message_type === 'CALLINIT')
                         {
                             console.log('starting call');
                             senddata.caller = this.user;
                             senddata.calee= obj.touser;
                             console.log(senddata);
                              for(soc in tosoc)
                              {
                                  
                                  tosoc[soc].sendData(JSON.stringify(senddata));
                              }
                         }
                        
                    }
                   
                 
                   if(obj !== undefined && obj.message_type ==="TEXTDATA"/*!== 'PCP' && obj.message_type !=='REQUEST' && obj.message_type !=='pong'*/)
                   {
                      senddata.self=true;
                      
                      var mysocks =  sockets[this.user];
                     
                      for(var ms=0; ms < mysocks.length; ms++)
                        mysocks[ms].sendData(JSON.stringify(senddata));
                   }
                   
              }
              //this.iscont = 'text';
			  }
			   else if (FIN !==0 && this.iscont==='bin' && this.messegeEnd ===true)
			   {
                   //console.log(this.iscont,'jojo');
                   this.messegeEnd = false;
                   this.iscont = '';
                 // console.log('opc');
                  //senddata = {user:this.user,message:'hello', message_type:'blob'}
				//console.log(Opcode,'bin');
                //console.log(b.toString());
               
                try{
                    
                   // bs = filterUnicode(b.toString());
                   // bs = b.toString());
                    
                   //if(b.length >0)
                     //console.log(b);
                    senddata = b;//..{message:bs,message_type:'binary'};
                    
                      tosock = sockets['guest1']
                      if(tosock !== undefined)
                      {
                      tosoc = tosock;//sockets[tosock];
                          if(tosoc !==undefined)
                             {
                                 tosoc.sendData(senddata,null,'binary');
                    //this.iscont = 'text';
                               }
                      }
                }
                catch(er)
                {
                    console.log(er);
                }
                
				//this.params.unshift(b.toString('binary'));
			   // this.controler[this.receiver].apply(this.controler,this.params);
			   }
               
               
               
	}


}

websocket.prototype.sendData = function(message, socket,type)
{
  
    if(type === undefined)
      type= 'string';
	var reservedBytes = [];
	reservedBytes[0]=129;
	var length = message.length;
  //  console.log(length);
	var startdata = 2;
	if(length <=125)
	{
		reservedBytes[1]=length;
	}
	else if(length >=126 && length <= 65535)
	{
		reservedBytes[1]=126;
		reservedBytes[2] = (length >>8) & 0xFF;
		reservedBytes[3] = (length & 0xFF);
		
		startdata = 4;
		
	}
	else
	{
       
		reservedBytes[1]=127;
		reservedBytes[2] = (length >> 56) & 0xFF;
		reservedBytes[3] = (length >> 48) & 0xFF;
		reservedBytes[4] = (length >> 40) & 0xFF;
		reservedBytes[4] = (length >> 32)& 0xFF;
		reservedBytes[6] = (length >> 24) & 0xFF;
		reservedBytes[7] = (length > 16) & 0xFF;
		reservedBytes[8] = (length >> 8) & 0xFF;
		reservedBytes[9] = (length & 0xFF);
		startdata = 10;
		
		
	}
    
    if(type === 'string')
    {
     if(message.length > 0)
     {
	 for (var i = 0; i < message.length; i++){
        reservedBytes.push(message.charCodeAt(i));
    }
    
	//console.log(reservedBytes);
    try{
   // var bf = new buff(reservedBytes.toString());
	//console.log(reservedBytes);
	//this.controler[this.sender]()
   
   //console.log(message.length);
	this.socket.write(new buff(reservedBytes));
    }
    catch(er)
    {
        console.log(er);
    }
     }
    }
    else if(type === 'binary')
    {
        //var length = reservedBytes.length + message.length;
        //rbbuf  = new Buffer(length);
        
       reservedBytes[0]=130;
        //message = message.toString;
      // console.log(message.length);
        if(message.length > 0)
        {
           // msg = filterUnicode(message)
            
            try
            {
               
                //message= message.toString('binary');
               // console.log(message);
                // console.log(message[0]);
               // console.log(message[0].toString('binary'));]
               //message = message.toString();
               //console.log(message.toString('binary'));
               
               mbuff = new Buffer(message.length)
               
               // for(i=0;i<message.length;i++)
                //{ 
                 //   mbuff[i] = message[i];
                    //console.log(message.readUInt8(i));
                  // reservedBytes.push(message.charCodeAt(i));
                   // console.log(j);
                  //  console.log(message.readUInt8(i))
                  //console.log(message.toString('binary').charCodeAt(i));
                   //rbbuf.writeUInt8(message.readUInt8(j),i);
                //}
               // mbuff.write(message)
                //console.log(mbuff);
                rbbuf  = new Buffer(reservedBytes);
               // rbbuf.writeUInt8(0x2, 0);
            //   mbb = new Buffer(mbuff);
               
                newbuf = buff.concat([rbbuf,message]);
                //onsole.log(rbbuf);
             // reservedBytes[startdata]=abuff;
            //console.log(uiea.length);
            
            //if(reservedBytes.length <10)
            // console.log(message.length,'rlength');
            //reservedBytes.push(message);
            
          // console.log(reservedBytes);
           // console.log('i and i');
            this.socket.write(newbuf); 
            }
            catch(error)
            {
                console.log(error);
            }
        }
        else
        { 
           // return;
              //reservedBytes.push(72);
            //this.socket.write(new buff(reservedBytes));
        }
    }
	
}


var escapable = /[\x00-\x1f\ud800-\udfff\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufff0-\uffff]/g;

function filterUnicode(quoted){

  escapable.lastIndex = 0;
  if( !escapable.test(quoted)) return quoted;

  return quoted.replace( escapable, function(a){
    return '';
  });
}


websocket.prototype.onclose = function(ev)
{
   
  
   for(var i=0; i< sockets[this.user].length; i++)
   {   
       
       if(sockets[this.user][i].socket === this.socket)
       {
         sockets[this.user].splice(i,1);
         console.log('removed');
       }
   }
	
   //  sockets[this.user] ={}
	//delete sockets[this.user];
     this.controler.setstatus(this.user,'offline');
   
}

websocket.prototype.pingpong = function()
{
    
    var obj = this;
    
    this.socket.pingssent = 0;
    var interval = setInterval(function() {
        if(obj.socket !== null){
        if (obj.socket.pingssent >= 2) {// how many missed pings you will tolerate before assuming connection broken.
            sokid = obj.socket.skid;
   
            obj.socket.destroy();
            sockets[obj.user].splice(sokid,1);
           
            if(sockets[obj.user].length ===0)
             sockets[obj.user].splice(0,1);
            clearInterval(interval);
        } else {
            obj.sendData(JSON.stringify({message_type:'ping'}));
            obj.socket.pingssent++;
        }
        }
    }, 60*1000);// 60 seconds between pings
   
}


module.exports = websocket;



//helpers

function initiateUserconnections(soc, contr,obj)
{
    contr.findfriendssocket(obj.user,function(doc)
    {
        
        var msg = {message_type:'INITIAL', connections:doc}
        soc.sendData(JSON.stringify(msg));
    }
    )
}